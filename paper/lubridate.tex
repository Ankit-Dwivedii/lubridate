\documentclass[article]{jss}
\usepackage{rotating}
\usepackage{pdfpages}
\usepackage{booktabs}
\usepackage{setspace}

\author{Garrett Grolemund\\Rice University \And 
        Hadley Wickham\\Rice University}
\title{Dates and Times Made Easy with \pkg{lubridate}}

\Plainauthor{Garrett Grolemund, Hadley Wickham}
\Plaintitle{Dates and times made easy with lubridate}
\Keywords{dates, times, time zones, daylight savings time, \proglang{R}}
\Plainkeywords{dates, times, time zones, daylight savings time,  R}

%% publication information
%% \Volume{13}
%% \Issue{9}
%% \Month{September}
%% \Year{2004}
%% \Submitdate{2004-09-29}
%% \Acceptdate{2004-09-29}

\Address{
  Garrett Grolemund\\
  Rice University\\
  Houston, TX 77251-1892, United States of America\\
  E-mail: \email{grolemund@rice.edu}
}

\Abstract{
  This paper presents the lubridate package for \proglang{R}, which
  facilitates working with dates and times.   
}

%\setstretch{2}
\begin{document}

\section{Introduction}

Many data sets have a time component, which can complicate research. Unlike other measures, units of time are inconsistent.  Seconds have a precise length, but the lengths of months, years, and even minutes depend on when they begin. Variations in Daylight savings time (DST) and time zones further complicate time data. Many \proglang{R} methods address these idiosyncrasies by creating new types of time objects.  But this approach makes research more complicated, not less. Moreover, the proliferation of time formats further complicates recognizing and accurately parsing time data.  \pkg{lubridate} acknowledges these problems, and provides methods to simplify working with time data in \proglang{R}. Specifically, \pkg{lubridate} makes it easier to:

\begin{itemize}
   \item automatically identify and parse date time data, Section~\ref{sec:parsing} 
   
    \item extract and modify components of a date-time, such as years, months, days, hours, minutes, seconds, Section~\ref{sec:accessors}
  
  \item perform math on date-times by clarifying the relationships that exist between two points of time, Section~\ref{sec:types}, and
    
  \item handle time zones and Daylight Savings Time, Section~\ref{sec:DST}, and time zones, Section~\ref{sec:tz}. 
  
\end{itemize}

\pkg{lubridate} also provides other useful utility functions, like \code{pretty.date}, which creates pretty sequences of tick marks for graphs that involve time data,  Section~\ref{sec:utils}. Moreover, \pkg{lubridate} creates an intuitive user interface similar to object oriented programming languages. Finally, \pkg{lubridate} methods are compatible with a wide-range of common date-time objects. These include character strings, POSIXct, POSIXlt, Date, chron, fCalendar, zoo, xts, its, tis, timeSeries, fts, and tseries objects.\\



The time concepts introduced by \pkg{lubridate} are inspired by the \proglang{Java} based JODA time project, \url{http://joda-time.sourceforge.net/}. This paper demonstrates the convenient tools provided in the \pkg{lubridate} package and ends with a case study, which uses \pkg{lubridate} in a real life example.

\pkg{lubridate} is available from \url{http://cran.r-project.org/}. Lubridate's development site it \url{http://github.com/hadley/lubridate}.

\section{Motivation}

To see how \pkg{lubridate} simplifies things, consider a common scenario. We have a character string and we'd like to read it in as a date-time, examine its various parts, and modify it accordingly. On the left are the base \proglang{R} methods we'd use for these tasks.  On the right are the lubridate methods.

\begin{center}
  \begin{tabular}{|l|l|l|}
    \hline
    Task & \proglang{base R} & \pkg{lubridate}\\
    \hline
    read in date & \code{date <- as.POSIXct("01-01-2010", } & \code{dmy("01-01-2010")}\\
    &\code{    format = "\%d-\%m-\%Y")} & \\
    && \\
    get month & \code{as.numeric(format(date, "\%m"))} or  & \code{month(date)}\\
   & \code{as.posixlt(date)$month + 1} &\\
    && \\
    change month & \code{date <- as.POSIXct(format(date, } & \code{month(date) <- 2} \\
   &  \code{    "\%Y-2-\%d"))} & \\
    && \\
    get previous day & \code{seq(date, length = 2, by = "-1 day")[2]}  & \code{date - days(1)} \\
    && \\
    display in new &\code{as.POSIXct(format(as.POSIXct(date),}  & \code{with_tz(date, "UTC")}\\
    time zone & \code{    tz = "UTC"), tz = "UTC")} &\\
    \hline
\end{tabular}
\end{center}

Note that the correct base \proglang{R} methods will change if we start with a time object instead of a character string. 

\section{Comparison table}

The following table shows how \pkg{lubridate} can simplify each of the common date time tasks presented in RNews Volume 4/1, June 2004.
% Always a good idea to show some examples right off the bat.  This helps
% people understand why they should bother reading the paper

\includepdf[angle=90]{comparison-table}


\section{Parsing date-times}
\label{sec:parsing}

With \pkg{lubridate}, we can read dates into R using the \code{ymd()} series of functions. The letters y, m, and d correspond to the year, month, and day elements of a date-time. To read in a date, choose the function name whose matches the order of elements in your date-time object. For example,\\

\code{R> ydm("2010-31-12")}\\
\code{[1] "2010-12-31 CST"}\\

or

\code{R> ymd("2010.12.31")}\\
\code{[1] "2010-12-31 CST"}\\


These functions create a POSIXct date-time object that matches the date described by the character string.  The functions automatically recognize the following separators: ``-", ``/", ``.", and ``" (i.e., no separators). If a \code{ymd()} function is applied to a vector of dates, all of the dates are considered to have the same order and the same separators. Functions also exist for times recorded in hours, minutes, and seconds. The \code{ymd()} functions work with any date-time object that can be converted to a character string. When applied to a vector of dates, a \code{ymd()} function will also return a message that shows which format was used to parse the dates. Table~\ref{tbl:parsers} lists all of the \code{ymd()} series parsing functions.

Sometimes we are given a vector of dates of an unknown format. \code{guess_format()} scans the vector and returns the format, including separators, that successfully parses the most dates within the vector. \\

\code{R> x <- c("2009/01/01", "2009/01/02", "2009/01/03")}\\
\code{R> possible.orderings <-list(c("\%y", "\%m", "\%d"), c("\%Y", "\%m", "\%d"))}\\
\code{R> guess_format(x, possible.orderings)}\\
\code{"\%Y/\%m/\%d" }\\

Since \code{ymd()} and its related functions depend only on the ordering of date elements, they can be used to read in all legible date classes.


\begin{table}
  \begin{center}
  \begin{tabular}{ll}
  \toprule
  Order of elements in date-time & Parse function\\
  \midrule
  year, month, day & \code{ymd}\\
  year, day, month  & \code{ydm}\\
  month, day, year & \code{mdy}\\
  day, month, year & \code{dmy}\\
  hour, minute & \code{hm}\\
  hour, minute, second & \code{hms}\\
  year, month, day, hour, minute, second & \code{ymd.hms}\\
  \bottomrule
    
  \end{tabular}
  \end{center}
  \caption{Parse functions based on order of date-time elements.}
  \label{tbl:parsers}
\end{table}

\section{Manipulating date-times} 
\label{sec:accessors}

\subsection{Extracting elements}
Every date-time object contains information about some or all of the following elements of a moment of time: the year, month, week, day, hour, minute, second, it occurs in as well as the time zone it has been recorded in. We can extract each element with the accessor function that has its name, See Table~\ref{tbl:accessors}. For example,  if we save the current system time\\

\code{R> date <- now()}\\
\code{[1] "2010-02-25 09:51:48 CST"}\\

we can extract each of its elements.\\

\code{R> year(date)}\\
\code{[1] 2010}\\

\code{R> month(date)}\\
\code{[1] 2}\\

\code{R> minute(date)}\\
\code{[1]  51}\\


\begin{table}
  \begin{center}
  \begin{tabular}{ll}
  \toprule
  Date component & Accessor\\
  \midrule
  Year & \code{year}\\
  Month & \code{month} \\
  Week  &\code{week} \\
  Day of year & \code{yday} \\
  Day of month & \code{mday}\\
  Day of week & \code{wday}\\
  Hour & \code{hour}\\
  Minute & \code{minute}\\
  Second & \code{second}\\
  Time Zone & \code{tz}\\
  \bottomrule
    
  \end{tabular}
  \end{center}
  \caption{Date-time accessors supported by lubridate.}
  \label{tbl:accessors}
\end{table}

We can also use any of the accessor functions to set values. For example, we could use \code{day()} to set the value we wish our date to have in its days element.\\

\code{R> day(date) <- 5}\\
\code{[1] "2010-02-05 09:51:48 CST"}\\

or\\

\code{R> minute(dates) <- mean(minute(dates))}\\

Note that if we set an element to a larger value than it supports, the difference will correctly roll over into the next higher element. For example,\\

\code{R> day(date) <- 30}\\
\code{[1] "2010-03-02 09:51:48 CST"}\\

Lubridate also provides a generic update method for dates, \code{update.Date}.  This is useful if you want to change multiple attributes simultaneously, or want to create a modified copy, rather than transforming in place.\\

\code{R> update(date, year = 2010, month = 1, day = 1)}\\
\code{[1] "2010-01-01 09:51:48 CST"}\\

Finally, we can also change dates by adding or subtracting units of time from them. For example,\\

\code{R> date + days(2) + hours(3) + seconds(59)}\\
\code{[1] "2010-01-03 12:52:47 CST"}\\

This method is discussed further in the next section.


\section{Math with date-times}
\label{sec:types}
\pkg{lubridate} allows math with date-times by introducing four new time related objects. An \emph{instant} is any object that records a date-time. \emph{Durations}, \emph{periods}, and \emph{intervals} provide three ways to measure timespans. Durations are used when we are interested in the exact length of a time span, such as the life of a light bulb in seconds. Periods allow us to work with changes in clock time, which usually do not have uniform lengths, e.g. a month. Intervals combine periods and durations by anchoring a time span to an instant of time. \pkg{lubridate} borrows these concepts from the \proglang{JODA} time project. For more information about instants, durations, periods, and intervals, please visit the \proglang{JODA} time project at  \url{http://joda-time.sourceforge.net/}. 

\subsubsection{Instants}
\label{sec:instants}

Instants are specific moments in time. Instants can be manipulated mathematically by adding or subtracting periods and durations from them. Moreover, periods, durations, and intervals can be created by taking the difference between two instants. \pkg{lubridate} does not create instant class objects. Any date-time object that refers to a moment of time is treated as an instant. We can test if an object is an instant by using \code{is.instant()}. For example,\\

\code{R> is.instant(364)}\\
\code{[1] FALSE}\\

\code{R> is.instant(date)}\\
\code{[1] TRUE}\\

\subsubsection{Time zones}
\label{sec:tz}

A single instant can be, and is, labeled in many different ways.  The most popular of these is clock time: the time that would be recorded on a clock at a given instant. Clock times for an instant vary from place to place depending on the time zone. When working with instants, it is standard to give the clock times that appear in the Greenwich Meridian Time (GMT) or Coordinated Universal Time (UTC) time zones.  This saves calculations, but can be annoying if your computer insists on translating times to your current time zone.  It may also be inconvenient to discuss clock times that occur in a place unrelated to the data.

\pkg{lubridate} eases the frustration caused by time zones in two ways. We can change the the time zone in which a clock time is displayed by using the function \code{with_tz()}. This changes how the time is displayed, but not the instant that is referred to. For example, using the date we created earlier,\\

\code{R> date}\\
\code{[1] "2010-01-01 09:51:48 CST"}\\
\code{R> with_tz(date, "UTC")}\\
\code{[1] "2010-01-01 15:51:48 UTC"}\\

Occasionally, it is useful to keep the same clock time and change the time zone it is assigned to. This creates a new instant that happens to have the same clock time, but in a different time zone. This switch is accomplished with the \code{update()} function.\\

\code{R> date}\\
\code{[1] "2010-01-01 09:51:48 CST"}\\
\code{R> update(date, tz = "UTC")}\\
\code{[1] "2010-01-01 09:51:48 UTC"}\\


\subsection{Relative time vs. exact time}

Durations and periods represent two different but common ways of measuring time: an ``exact" way and a ``relative" way.  Errors arise when we fail to consider which we are using.  Seconds are the only units of time that have a consistent length. The lengths of larger units sometimes vary due to daylight savings time, leap years, and even leap seconds. 

%Why have we adopted such frustrating conventions? Time units are mapped to the rotation of the Earth as well as the Earth's revolution about the sun. Because these events do not align or repeat themselves with the precision of an interval scale, clock times are periodically re-calibrated to retain these useful astronomical mappings.

Each manipulation of the official time disrupts the length of units of time that occur near the change. As a result, the length of any unit of time (other than seconds) is relative to when that unit begins. For example, a year that begins on January 1, 2010 is 365 days long, but a year that begins on January, 1, 2012 is 366 days long. Since these units are relative to when they begin, \pkg{lubridate} refers to time spans measured in such units as relative time. The length of time spans measured in only seconds do not depend on when they begin. These spans are referred to as exact time.

Research involving time data may be interested in exact time, relative time, or both. The speed of a physical object is most precisely stated in exact time. The opening bids on most stock markets occur at the same relative time each day.  

\subsection{Durations}
\label{sec:durations}
Durations are time spans specified by a precise number of seconds. They are not affected by conventions such as leap years and Daylight Savings Time. Because of this, durations always have a consistent length and can be easily compared to other durations. \pkg{lubridate} uses the \code{difftime} class from base \proglang{R} for durations. Additional \code{difftime} methods have been created to facilitate this. 

For large durations, it becomes inconvenient to display durations as numbers of seconds. For this reason, \pkg{lubridate} displays durations in various units, but these units are only estimates given for convenience. The underlying object is always recorded as a fixed number of seconds. For display and creation purposes, units are converted to seconds using their most common lengths in seconds: Minutes = 60 seconds, hours = 3600 seconds, days = 86400 seconds, weeks = 604800. Units larger than weeks are not used due to their variability.

Duration objects can be easily created with the helper functions 
\code{eweeks()}, \code{edays()}, \code{eminutes()}, and  \code{eseconds()}. These objects can be added and subtracted to date-times. For example,\\

\code{R> eminutes(2)}\\
\code{Time difference of 2 mins}\\

\code{R> eweeks(1) + edays(6) + ehours(2) + eminutes(1.5) + eseconds(3)}\\
\code{Time difference of 1.869201 weeks}\\

\code{R> c(1:3) * ehours(1) }\\
\code{Time differences in hours}\\
\code{[1] 1 2 3}\\

Duration objects can be added to instants, intervals, and other duration objects. \\

\code{R> date}\\
\code{[1] "2010-01-01 09:51:48 CST"}\\
\code{R> date + eweeks(10)}\\
\code{[1] "2010-03-12 09:51:48 CST"}\\

\subsection{Periods}
\label{sec:periods}

Periods record the change in the clock time between two date-times. Hence, they are measured in relative units such as years, months, days, hours, and minutes.  For convenience, a period can also be measured in seconds. Leap years, leap seconds, and Daylight Savings Time can expand or contract the exact length of a period, but the relative length will remain unchanged. Because the length of a period is relative to when it begins, periods do not have a fixed length until they are paired with a start date. For this reason, periods can not be converted to and from durations.

Period objects can be easily created with the helper functions \code{years}, \code{months}, \code{weeks}, \code{days}, \code{minutes}, \code{seconds}. \\

\code{R> months(3)}\\
\code{[1] 3 months}\\

\code{R> months(3) + days(2)}\\
\code{[1] 3 months and 2 days}\\

Period objects can be added to instants and intervals just like duration objects. However, periods cannot be added to durations.\\

\code{R> date}\\
\code{[1] "2010-01-01 09:51:48 CST"}\\
\code{R> date + days(3) - hours(2)}\\
\code{[1] "2010-01-04 07:51:48 CST"}\\

Why would we use a period instead of a duration? Periods allow us to model the passage of time in a different way than durations. For example, consider 1:59:59AM on March, 8 2008. This is the second before daylight savings time (DST) goes into effect and advances the clock time by an hour in many parts of the world.\\

\code{R> DSTdate <- ymd.hms("2009-03-08 01:59:59")}\\

Adding a period ignores the change in Daylight Savings Time. For example, we can model the clock time that appears to occur 7 hours later.\\

\code{R> DSTdate + hours(7) + seconds(1)}\\
\code{[1] "2009-03-08 09:00:00 CDT"}\\

Adding a duration shows the clock time that corresponds to the moment that actually occurs exactly 7 hours later. (Recall that durations are measured in seconds. Larger units can be used for convenience, but these correspond to a fixed number of seconds.)\\

\code{R> DSTdate + ehours(7) + seconds(1)}\\
\code{[1] "2009-03-08 10:00:00 CDT"}\\

If we had been trying to model the start of market hours, we would have overshot it by an hour. \\

Periods also allow us to model events that can not be easily described with exact times. For example, the last day of each month. Below we start with the last day of January and add a sequence of months.\\

\code{R> ymd(20100131) + months(0:11)}\\
\code{ [ [1] "2010-01-31 CST" "2010-02-28 CST" "2010-03-31 CDT" "2010-04-30 CDT"}\\
 \code{[5] "2010-05-31 CDT" "2010-06-30 CDT" "2010-07-31 CDT" "2010-08-31 CDT"}\\
\code{ [9] "2010-09-30 CDT" "2010-10-31 CDT" "2010-11-30 CST" "2010-12-31 CST"}\\

\subsection{Intervals}
\label{sec:intervals}

A time span ceases to be ambiguous when it is paired with a starting date. We can then calculate the exact lengths of all relative units involved. This suggests a way of converting between periods and durations. If we first anchor a period to a starting date-time, we can accurately convert it to a duration and vice versa. \proglang{Joda-Time} defines such time span, instant pairs as intervals. Intervals can be created with the function \code{new_interval()} or from an existing period or duration with \code{as.interval()}.\\

\code{R> new_interval(DSTdate, date)}\\
\code{[1] 299.3277 days beginning at 2009-03-08 01:59:59}\\

We can also automatically create intervals by subtracting one instant from another.\\

\code{R> date - DSTdate}\\
\code{[1] 299.3277 days beginning at 2009-03-08 01:59:59}\\

In general, intervals can not be added to instants. An exception occurs only if we add an interval to its start or end date-time.\\


\subsection{Daylight Savings Time}
\label{sec:DST}

In many parts of the world, the official clock time springs forward by one hour in the spring and falls back one hour in the fall. This system of Daylight Savings Time attempts to maximize the productive hours of daylight throughout the year. We've already seen how \pkg{lubridate} users can avoid the frustrations of Daylight Savings Time by thinking carefully whether to use periods or durations. However, Daylight Savings time creates some additional issues.

When the clock time advances by an hour in the spring, it creates an hour long gap in the official record of clock times. If we create a clock time that appears in this gap (either by changing the elements of a time or by adding a period), \pkg{lubridate} will return a NA to reflect that this time does not exist.

In the fall, clock time repeats itself for an hour. By default, clock times created during this hour will be assigned to the matching instant that occurs during the first time the clock time is displayed.

\section{Other convenience functions}
\label{sec:utils}

Lubridate also provides other handy utility functions, for

\begin{itemize}
  \item Creating pretty sequences of dates and times for tick marks on plots, \code{pretty.dates}
  
  \item Rounding dates, \code{floor_date}, \code{ceiling_date}, \code{round_date}.

  \item Accessing the current time, \code{now()}, and date \code{today()}.  There are existing methods to do this, but they have hard to remember names and return the dates in inconsistent formats.
  
\end{itemize}



\section{Case Study}

\section*{Acknowledgements}
I'd like to thank the National Science Foundation. This work was supported by the NSF under Grant WHAT GRANT NUMBER? 
% Acknowledge NSF grant here, since it paid for your summer.

\section*{References}

\end{document}
